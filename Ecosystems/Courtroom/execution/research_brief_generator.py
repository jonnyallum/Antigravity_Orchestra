"""
Research Brief Generator - Creates structured research briefs for The Courtroom.
Part of the Courtroom Ecosystem | Jai.OS 4.0

Generates a standardized research brief template that @Scholar uses to begin
investigations. Ensures every research task has a clear hypothesis, scope,
source requirements, and delivery format.

Usage:
    python research_brief_generator.py --topic "AI Agent Architectures" --requester "@Marcus"
    python research_brief_generator.py --interactive
"""

import os
import sys
import json
import argparse
from pathlib import Path
from datetime import datetime, timezone

ROOT = Path(__file__).parent.parent
DOSSIERS_DIR = ROOT / ".tmp" / "dossiers"
BRIEFS_DIR = ROOT / ".tmp" / "briefs"
TASK_HISTORY = ROOT / ".agent" / "memory" / "task-history.json"

BRIEF_TEMPLATE = """# Research Brief: {topic}
> **Generated:** {timestamp}
> **Brief ID:** {brief_id}
> **Requester:** {requester}
> **Assigned To:** @Scholar (Dr. Elias Thorne)
> **Priority:** {priority}
> **Status:** OPEN

---

## 1. Research Question
{research_question}

## 2. Hypothesis (Testable)
{hypothesis}

## 3. Scope & Constraints
- **In Scope:** {in_scope}
- **Out of Scope:** {out_of_scope}
- **Time Budget:** {time_budget}
- **Depth Level:** {depth_level}

## 4. Source Requirements
| Source Type | Minimum Count | Notes |
|:-----------|:-------------|:------|
| Primary Sources | 3 | Peer-reviewed, official documentation, direct data |
| Secondary Sources | 2 | Industry reports, expert analysis |
| Counter-Evidence | 1 | Actively seek contradicting viewpoints |

## 5. Deliverable Format
- [ ] Structured dossier (`.tmp/dossiers/{slug}-{date}.md`)
- [ ] Confidence levels on all claims (Verified/Probable/Unverified/Debunked)
- [ ] Evidence chain for each finding
- [ ] Counter-arguments addressed
- [ ] Recommendations with risk assessment

## 6. Quality Gates Required
- [ ] @Counsel Logic Stress Test (SOP-003)
- [ ] @Advocate Adversarial Review (SOP-001)
- [ ] @Vigil Truth Verification

## 7. Courtroom Pipeline
```
@Scholar (Research) -> @Parser (Data Extraction) -> @Counsel (Logic Structure)
    -> @Advocate (Adversarial Review) -> @Vigil (Truth Lock) -> Verdict
```

---

*The Courtroom | Jai.OS 4.0 | Brief generated by research_brief_generator.py*
"""

DEPTH_LEVELS = {
    "surface": "Quick survey — 30 min max, 3+ sources, summary findings",
    "standard": "Full investigation — 1 session, 5+ sources, structured dossier",
    "deep": "PhD-level deep dive — multi-session, 10+ sources, peer-reviewed dossier",
}

PRIORITIES = ["P1 (Critical)", "P2 (Standard)", "P3 (Background)"]


def generate_brief_id(topic: str) -> str:
    """Generate a unique brief ID from topic and timestamp."""
    slug = topic.lower().replace(" ", "-")[:30]
    ts = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M")
    return f"RB-{slug}-{ts}"


def slugify(text: str) -> str:
    """Convert text to filename-safe slug."""
    return text.lower().replace(" ", "-").replace("/", "-")[:50]


def interactive_mode() -> dict:
    """Gather brief details interactively."""
    print("\n=== The Courtroom | Research Brief Generator ===\n")

    topic = input("Research Topic: ").strip()
    if not topic:
        print("ERROR: Topic is required.")
        sys.exit(1)

    research_question = input("Research Question (testable): ").strip()
    hypothesis = input("Hypothesis to test: ").strip() or "To be determined during investigation"

    requester = input("Requester (e.g. @Marcus): ").strip() or "@Marcus"

    print("\nDepth Levels:")
    for key, desc in DEPTH_LEVELS.items():
        print(f"  [{key}] {desc}")
    depth = input("Depth Level [standard]: ").strip() or "standard"
    if depth not in DEPTH_LEVELS:
        depth = "standard"

    print("\nPriorities: P1 (Critical), P2 (Standard), P3 (Background)")
    priority = input("Priority [P2]: ").strip() or "P2 (Standard)"

    in_scope = input("In Scope: ").strip() or "All aspects of the research question"
    out_of_scope = input("Out of Scope: ").strip() or "Implementation details"
    time_budget = input("Time Budget [1 session]: ").strip() or "1 session"

    return {
        "topic": topic,
        "research_question": research_question or f"What is the current state of {topic}?",
        "hypothesis": hypothesis,
        "requester": requester,
        "priority": priority,
        "depth_level": f"{depth} — {DEPTH_LEVELS[depth]}",
        "in_scope": in_scope,
        "out_of_scope": out_of_scope,
        "time_budget": time_budget,
    }


def cli_mode(args) -> dict:
    """Build brief from CLI arguments."""
    depth = args.depth or "standard"
    return {
        "topic": args.topic,
        "research_question": args.question or f"What is the current state of {args.topic}?",
        "hypothesis": args.hypothesis or "To be determined during investigation",
        "requester": args.requester or "@Marcus",
        "priority": args.priority or "P2 (Standard)",
        "depth_level": f"{depth} — {DEPTH_LEVELS.get(depth, DEPTH_LEVELS['standard'])}",
        "in_scope": args.scope or "All aspects of the research question",
        "out_of_scope": args.exclude or "Implementation details",
        "time_budget": args.time or "1 session",
    }


def generate_brief(params: dict) -> str:
    """Generate the research brief from parameters."""
    brief_id = generate_brief_id(params["topic"])
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    slug = slugify(params["topic"])
    date = datetime.now(timezone.utc).strftime("%Y-%m-%d")

    return BRIEF_TEMPLATE.format(
        topic=params["topic"],
        timestamp=timestamp,
        brief_id=brief_id,
        requester=params["requester"],
        priority=params["priority"],
        research_question=params["research_question"],
        hypothesis=params["hypothesis"],
        in_scope=params["in_scope"],
        out_of_scope=params["out_of_scope"],
        time_budget=params["time_budget"],
        depth_level=params["depth_level"],
        slug=slug,
        date=date,
    )


def save_brief(content: str, topic: str) -> Path:
    """Save the brief to the briefs directory."""
    BRIEFS_DIR.mkdir(parents=True, exist_ok=True)
    slug = slugify(topic)
    date = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    filename = f"{slug}-{date}.md"
    filepath = BRIEFS_DIR / filename
    filepath.write_text(content, encoding="utf-8")
    return filepath


def log_to_task_history(topic: str, brief_path: Path):
    """Log the brief generation to task history."""
    TASK_HISTORY.parent.mkdir(parents=True, exist_ok=True)
    history = []
    if TASK_HISTORY.exists():
        try:
            history = json.loads(TASK_HISTORY.read_text(encoding="utf-8"))
        except (json.JSONDecodeError, ValueError):
            history = []

    history.append({
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "agent": "@Scholar",
        "task": f"Research brief generated: {topic}",
        "output": str(brief_path),
        "status": "brief_created",
        "ecosystem": "Courtroom",
    })

    TASK_HISTORY.write_text(json.dumps(history, indent=2), encoding="utf-8")


def main():
    parser = argparse.ArgumentParser(description="Generate a Courtroom research brief")
    parser.add_argument("--topic", help="Research topic")
    parser.add_argument("--question", help="Research question")
    parser.add_argument("--hypothesis", help="Testable hypothesis")
    parser.add_argument("--requester", help="Requesting agent (default: @Marcus)")
    parser.add_argument("--priority", help="P1/P2/P3")
    parser.add_argument("--depth", choices=["surface", "standard", "deep"], help="Research depth")
    parser.add_argument("--scope", help="In scope")
    parser.add_argument("--exclude", help="Out of scope")
    parser.add_argument("--time", help="Time budget")
    parser.add_argument("--interactive", action="store_true", help="Interactive mode")

    args = parser.parse_args()

    if args.interactive:
        params = interactive_mode()
    elif args.topic:
        params = cli_mode(args)
    else:
        print("ERROR: Provide --topic or use --interactive mode.")
        print("Usage: python research_brief_generator.py --topic 'AI Agents' --requester '@Marcus'")
        sys.exit(1)

    brief = generate_brief(params)
    filepath = save_brief(brief, params["topic"])
    log_to_task_history(params["topic"], filepath)

    print(f"\nResearch brief generated: {filepath}")
    print(f"Assigned to: @Scholar (Dr. Elias Thorne)")
    print(f"Pipeline: @Scholar -> @Parser -> @Counsel -> @Advocate -> @Vigil -> Verdict")


if __name__ == "__main__":
    main()
